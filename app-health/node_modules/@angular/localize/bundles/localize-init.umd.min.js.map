{"version":3,"sources":["packages/localize/localize-init.umd.js"],"names":["factory","define","amd","__globalThis","globalThis","__window","window","__self","self","WorkerGlobalScope","__global","global","$localize","messageParts","expressions","_i","arguments","length","translate","translation","message","stripBlock","raw","i","BLOCK_MARKER","messagePart","rawMessagePart","charAt","substring","findEndOfBlock","cooked","cookedIndex","rawIndex","Error"],"mappings":";;;;;CAMC,SAAUA,GACW,mBAAXC,QAAyBA,OAAOC,IAAMD,OAAO,yBAA0BD,GAC9EA,IAFJ,EAGE,WAAe;;;;;;;OASb,IAAIG,EAAqC,oBAAfC,YAA8BA,WACpDC,EAA6B,oBAAXC,QAA0BA,OAC5CC,EAAyB,oBAATC,MAAqD,oBAAtBC,mBAC/CD,gBAAgBC,mBAAqBD,KACrCE,EAA6B,oBAAXC,QAA0BA,OAwG5CC,EAAY,SAAUC,GAEtB,IADA,IAAIC,EAAc,GACTC,EAAK,EAAGA,EAAKC,UAAUC,OAAQF,IACpCD,EAAYC,EAAK,GAAKC,UAAUD,GAEpC,GAAIH,EAAUM,UAAW,CAErB,IAAIC,EAAcP,EAAUM,UAAUL,EAAcC,GACpDD,EAAeM,EAAY,GAC3BL,EAAcK,EAAY,GAG9B,IADA,IAAIC,EAAUC,EAAWR,EAAa,GAAIA,EAAaS,IAAI,IAClDC,EAAI,EAAGA,EAAIV,EAAaI,OAAQM,IACrCH,GAAWN,EAAYS,EAAI,GAAKF,EAAWR,EAAaU,GAAIV,EAAaS,IAAIC,IAEjF,OAAOH,GAEPI,EAAe,IAcnB,SAASH,EAAWI,EAAaC,GAC7B,OAAOA,EAAeC,OAAO,KAAOH,EAChCC,EAAYG,UAYpB,SAASC,EAAeC,EAAQR,GAO5B,IAAK,IAAIS,EAAc,EAAGC,EAAW,EAAGD,EAAcD,EAAOb,OAAQc,IAAeC,IAChF,GAAsB,OAAlBV,EAAIU,GACJA,SAEC,GAAIF,EAAOC,KAAiBP,EAC7B,OAAOO,EAGf,MAAM,IAAIE,MAAM,6CAAgDX,EAAM;;;;;;;;;;;;;;OA3B5CO,CAAeJ,EAAaC,GAAkB,GACpED,GAtIMtB,GAAgBO,GAAYL,GAAYE,GAmL9CK,UAAYA","sourcesContent":["/**\n * @license Angular v9.0.7\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\n(function (factory) {\n    typeof define === 'function' && define.amd ? define('@angular/localize/init', factory) :\n    factory();\n}((function () { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __globalThis = typeof globalThis !== 'undefined' && globalThis;\n    var __window = typeof window !== 'undefined' && window;\n    var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n        self instanceof WorkerGlobalScope && self;\n    var __global = typeof global !== 'undefined' && global;\n    // Always use __globalThis if available; this is the spec-defined global variable across all\n    // environments.\n    // Then fallback to __global first; in Node tests both __global and __window may be defined.\n    var _global = __globalThis || __global || __window || __self;\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Tag a template literal string for localization.\n     *\n     * For example:\n     *\n     * ```ts\n     * $localize `some string to localize`\n     * ```\n     *\n     * **Providing meaning, description and id**\n     *\n     * You can optionally specify one or more of `meaning`, `description` and `id` for a localized\n     * string by pre-pending it with a colon delimited block of the form:\n     *\n     * ```ts\n     * $localize`:meaning|description@@id:source message text`;\n     *\n     * $localize`:meaning|:source message text`;\n     * $localize`:description:source message text`;\n     * $localize`:@@id:source message text`;\n     * ```\n     *\n     * This format is the same as that used for `i18n` markers in Angular templates. See the\n     * [Angular 18n guide](guide/i18n#template-translations).\n     *\n     * **Naming placeholders**\n     *\n     * If the template literal string contains expressions, then the expressions will be automatically\n     * associated with placeholder names for you.\n     *\n     * For example:\n     *\n     * ```ts\n     * $localize `Hi ${name}! There are ${items.length} items.`;\n     * ```\n     *\n     * will generate a message-source of `Hi {$PH}! There are {$PH_1} items`.\n     *\n     * The recommended practice is to name the placeholder associated with each expression though.\n     *\n     * Do this by providing the placeholder name wrapped in `:` characters directly after the\n     * expression. These placeholder names are stripped out of the rendered localized string.\n     *\n     * For example, to name the `items.length` expression placeholder `itemCount` you write:\n     *\n     * ```ts\n     * $localize `There are ${items.length}:itemCount: items`;\n     * ```\n     *\n     * **Escaping colon markers**\n     *\n     * If you need to use a `:` character directly at the start of a tagged string that has no\n     * metadata block, or directly after a substitution expression that has no name you must escape\n     * the `:` by preceding it with a backslash:\n     *\n     * For example:\n     *\n     * ```ts\n     * // message has a metadata block so no need to escape colon\n     * $localize `:some description::this message starts with a colon (:)`;\n     * // no metadata block so the colon must be escaped\n     * $localize `\\:this message starts with a colon (:)`;\n     * ```\n     *\n     * ```ts\n     * // named substitution so no need to escape colon\n     * $localize `${label}:label:: ${}`\n     * // anonymous substitution so colon must be escaped\n     * $localize `${label}\\: ${}`\n     * ```\n     *\n     * **Processing localized strings:**\n     *\n     * There are three scenarios:\n     *\n     * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a\n     * transpiler, removing the tag and replacing the template literal string with a translated\n     * literal string from a collection of translations provided to the transpilation tool.\n     *\n     * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and\n     * reorders the parts (static strings and expressions) of the template literal string with strings\n     * from a collection of translations loaded at run-time.\n     *\n     * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\n     * the original template literal string without applying any translations to the parts. This\n     * version is used during development or where there is no need to translate the localized\n     * template literals.\n     * @param messageParts a collection of the static parts of the template string.\n     * @param expressions a collection of the values of each placeholder in the template string.\n     * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\n     */\n    var $localize = function (messageParts) {\n        var expressions = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            expressions[_i - 1] = arguments[_i];\n        }\n        if ($localize.translate) {\n            // Don't use array expansion here to avoid the compiler adding `__read()` helper unnecessarily.\n            var translation = $localize.translate(messageParts, expressions);\n            messageParts = translation[0];\n            expressions = translation[1];\n        }\n        var message = stripBlock(messageParts[0], messageParts.raw[0]);\n        for (var i = 1; i < messageParts.length; i++) {\n            message += expressions[i - 1] + stripBlock(messageParts[i], messageParts.raw[i]);\n        }\n        return message;\n    };\n    var BLOCK_MARKER = ':';\n    /**\n     * Strip a delimited \"block\" from the start of the `messagePart`, if it is found.\n     *\n     * If a marker character (:) actually appears in the content at the start of a tagged string or\n     * after a substitution expression, where a block has not been provided the character must be\n     * escaped with a backslash, `\\:`. This function checks for this by looking at the `raw`\n     * messagePart, which should still contain the backslash.\n     *\n     * @param messagePart The cooked message part to process.\n     * @param rawMessagePart The raw message part to check.\n     * @returns the message part with the placeholder name stripped, if found.\n     * @throws an error if the block is unterminated\n     */\n    function stripBlock(messagePart, rawMessagePart) {\n        return rawMessagePart.charAt(0) === BLOCK_MARKER ?\n            messagePart.substring(findEndOfBlock(messagePart, rawMessagePart) + 1) :\n            messagePart;\n    }\n    /**\n     * Find the end of a \"marked block\" indicated by the first non-escaped colon.\n     *\n     * @param cooked The cooked string (where escaped chars have been processed)\n     * @param raw The raw string (where escape sequences are still in place)\n     *\n     * @returns the index of the end of block marker\n     * @throws an error if the block is unterminated\n     */\n    function findEndOfBlock(cooked, raw) {\n        /***********************************************************************************************\n         * This function is repeated in `src/utils/messages.ts` and the two should be kept in sync.\n         * The reason is that this file is marked as having side-effects, and if we import `messages.ts`\n         * into it, the whole of `src/utils` will be included in this bundle and none of the functions\n         * will be tree shaken.\n         ***********************************************************************************************/\n        for (var cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {\n            if (raw[rawIndex] === '\\\\') {\n                rawIndex++;\n            }\n            else if (cooked[cookedIndex] === BLOCK_MARKER) {\n                return cookedIndex;\n            }\n        }\n        throw new Error(\"Unterminated $localize metadata block in \\\"\" + raw + \"\\\".\");\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Attach $localize to the global context, as a side-effect of this module.\n    _global.$localize = $localize;\n\n})));\n//# sourceMappingURL=localize-init.umd.js.map\n"]}