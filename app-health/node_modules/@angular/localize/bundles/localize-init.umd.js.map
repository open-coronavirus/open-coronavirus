{"version":3,"file":"localize-init.umd.js","sources":["../../../../../../../packages/localize/src/localize/src/global.ts","../../../../../../../packages/localize/src/localize/src/localize.ts","../../../../../../../packages/localize/src/localize/index.ts","../../../../../../packages/localize/init/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// **********************************************************************************************\n// This code to access the global object is mostly copied from `packages/core/src/util/global.ts`\n\ndeclare global {\n  var WorkerGlobalScope: any;\n}\n\nconst __globalThis = typeof globalThis !== 'undefined' && globalThis;\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\n// Always use __globalThis if available; this is the spec-defined global variable across all\n// environments.\n// Then fallback to __global first; in Node tests both __global and __window may be defined.\nexport const _global: any = __globalThis || __global || __window || __self;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface LocalizeFn {\n  (messageParts: TemplateStringsArray, ...expressions: readonly any[]): string;\n\n  /**\n   * A function that converts an input \"message with expressions\" into a translated \"message with\n   * expressions\".\n   *\n   * The conversion may be done in place, modifying the array passed to the function, so\n   * don't assume that this has no side-effects.\n   *\n   * The expressions must be passed in since it might be they need to be reordered for\n   * different translations.\n   */\n  translate?: TranslateFn;\n  /**\n   * The current locale of the translated messages.\n   *\n   * The compile-time translation inliner is able to replace the following code:\n   *\n   * ```\n   * typeof $localize !== \"undefined\" && $localize.locale\n   * ```\n   *\n   * with a string literal of the current locale. E.g.\n   *\n   * ```\n   * \"fr\"\n   * ```\n   */\n  locale?: string;\n}\n\nexport interface TranslateFn {\n  (messageParts: TemplateStringsArray,\n   expressions: readonly any[]): [TemplateStringsArray, readonly any[]];\n}\n\n/**\n * Tag a template literal string for localization.\n *\n * For example:\n *\n * ```ts\n * $localize `some string to localize`\n * ```\n *\n * **Providing meaning, description and id**\n *\n * You can optionally specify one or more of `meaning`, `description` and `id` for a localized\n * string by pre-pending it with a colon delimited block of the form:\n *\n * ```ts\n * $localize`:meaning|description@@id:source message text`;\n *\n * $localize`:meaning|:source message text`;\n * $localize`:description:source message text`;\n * $localize`:@@id:source message text`;\n * ```\n *\n * This format is the same as that used for `i18n` markers in Angular templates. See the\n * [Angular 18n guide](guide/i18n#template-translations).\n *\n * **Naming placeholders**\n *\n * If the template literal string contains expressions, then the expressions will be automatically\n * associated with placeholder names for you.\n *\n * For example:\n *\n * ```ts\n * $localize `Hi ${name}! There are ${items.length} items.`;\n * ```\n *\n * will generate a message-source of `Hi {$PH}! There are {$PH_1} items`.\n *\n * The recommended practice is to name the placeholder associated with each expression though.\n *\n * Do this by providing the placeholder name wrapped in `:` characters directly after the\n * expression. These placeholder names are stripped out of the rendered localized string.\n *\n * For example, to name the `items.length` expression placeholder `itemCount` you write:\n *\n * ```ts\n * $localize `There are ${items.length}:itemCount: items`;\n * ```\n *\n * **Escaping colon markers**\n *\n * If you need to use a `:` character directly at the start of a tagged string that has no\n * metadata block, or directly after a substitution expression that has no name you must escape\n * the `:` by preceding it with a backslash:\n *\n * For example:\n *\n * ```ts\n * // message has a metadata block so no need to escape colon\n * $localize `:some description::this message starts with a colon (:)`;\n * // no metadata block so the colon must be escaped\n * $localize `\\:this message starts with a colon (:)`;\n * ```\n *\n * ```ts\n * // named substitution so no need to escape colon\n * $localize `${label}:label:: ${}`\n * // anonymous substitution so colon must be escaped\n * $localize `${label}\\: ${}`\n * ```\n *\n * **Processing localized strings:**\n *\n * There are three scenarios:\n *\n * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a\n * transpiler, removing the tag and replacing the template literal string with a translated\n * literal string from a collection of translations provided to the transpilation tool.\n *\n * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and\n * reorders the parts (static strings and expressions) of the template literal string with strings\n * from a collection of translations loaded at run-time.\n *\n * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\n * the original template literal string without applying any translations to the parts. This\n * version is used during development or where there is no need to translate the localized\n * template literals.\n * @param messageParts a collection of the static parts of the template string.\n * @param expressions a collection of the values of each placeholder in the template string.\n * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\n */\nexport const $localize: LocalizeFn = function(\n    messageParts: TemplateStringsArray, ...expressions: readonly any[]) {\n  if ($localize.translate) {\n    // Don't use array expansion here to avoid the compiler adding `__read()` helper unnecessarily.\n    const translation = $localize.translate(messageParts, expressions);\n    messageParts = translation[0];\n    expressions = translation[1];\n  }\n  let message = stripBlock(messageParts[0], messageParts.raw[0]);\n  for (let i = 1; i < messageParts.length; i++) {\n    message += expressions[i - 1] + stripBlock(messageParts[i], messageParts.raw[i]);\n  }\n  return message;\n};\n\nconst BLOCK_MARKER = ':';\n\n/**\n * Strip a delimited \"block\" from the start of the `messagePart`, if it is found.\n *\n * If a marker character (:) actually appears in the content at the start of a tagged string or\n * after a substitution expression, where a block has not been provided the character must be\n * escaped with a backslash, `\\:`. This function checks for this by looking at the `raw`\n * messagePart, which should still contain the backslash.\n *\n * @param messagePart The cooked message part to process.\n * @param rawMessagePart The raw message part to check.\n * @returns the message part with the placeholder name stripped, if found.\n * @throws an error if the block is unterminated\n */\nfunction stripBlock(messagePart: string, rawMessagePart: string) {\n  return rawMessagePart.charAt(0) === BLOCK_MARKER ?\n      messagePart.substring(findEndOfBlock(messagePart, rawMessagePart) + 1) :\n      messagePart;\n}\n\n/**\n * Find the end of a \"marked block\" indicated by the first non-escaped colon.\n *\n * @param cooked The cooked string (where escaped chars have been processed)\n * @param raw The raw string (where escape sequences are still in place)\n *\n * @returns the index of the end of block marker\n * @throws an error if the block is unterminated\n */\nfunction findEndOfBlock(cooked: string, raw: string): number {\n  /***********************************************************************************************\n   * This function is repeated in `src/utils/messages.ts` and the two should be kept in sync.\n   * The reason is that this file is marked as having side-effects, and if we import `messages.ts`\n   * into it, the whole of `src/utils` will be included in this bundle and none of the functions\n   * will be tree shaken.\n   ***********************************************************************************************/\n  for (let cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {\n    if (raw[rawIndex] === '\\\\') {\n      rawIndex++;\n    } else if (cooked[cookedIndex] === BLOCK_MARKER) {\n      return cookedIndex;\n    }\n  }\n  throw new Error(`Unterminated $localize metadata block in \"${raw}\".`);\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport {_global} from './src/global';\nexport {$localize, LocalizeFn, TranslateFn} from './src/localize';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {$localize, LocalizeFn, _global} from '../src/localize';\n\nexport {LocalizeFn, TranslateFn} from '../src/localize';\n\n// Attach $localize to the global context, as a side-effect of this module.\n_global.$localize = $localize;\n\n// `declare global` allows us to escape the current module and place types on the global namespace\ndeclare global {\n  /**\n   * Tag a template literal string for localization.\n   *\n   * For example:\n   *\n   * ```ts\n   * $localize `some string to localize`\n   * ```\n   *\n   * **Providing meaning, description and id**\n   *\n   * You can optionally specify one or more of `meaning`, `description` and `id` for a localized\n   * string by pre-pending it with a colon delimited block of the form:\n   *\n   * ```ts\n   * $localize`:meaning|description@@id:source message text`;\n   *\n   * $localize`:meaning|:source message text`;\n   * $localize`:description:source message text`;\n   * $localize`:@@id:source message text`;\n   * ```\n   *\n   * This format is the same as that used for `i18n` markers in Angular templates. See the\n   * [Angular 18n guide](guide/i18n#template-translations).\n   *\n   * **Naming placeholders**\n   *\n   * If the template literal string contains expressions, then the expressions will be automatically\n   * associated with placeholder names for you.\n   *\n   * For example:\n   *\n   * ```ts\n   * $localize `Hi ${name}! There are ${items.length} items.`;\n   * ```\n   *\n   * will generate a message-source of `Hi {$PH}! There are {$PH_1} items`.\n   *\n   * The recommended practice is to name the placeholder associated with each expression though.\n   *\n   * Do this by providing the placeholder name wrapped in `:` characters directly after the\n   * expression. These placeholder names are stripped out of the rendered localized string.\n   *\n   * For example, to name the `items.length` expression placeholder `itemCount` you write:\n   *\n   * ```ts\n   * $localize `There are ${items.length}:itemCount: items`;\n   * ```\n   *\n   * **Escaping colon markers**\n   *\n   * If you need to use a `:` character directly at the start of a tagged string that has no\n   * metadata block, or directly after a substitution expression that has no name you must escape\n   * the `:` by preceding it with a backslash:\n   *\n   * For example:\n   *\n   * ```ts\n   * // message has a metadata block so no need to escape colon\n   * $localize `:some description::this message starts with a colon (:)`;\n   * // no metadata block so the colon must be escaped\n   * $localize `\\:this message starts with a colon (:)`;\n   * ```\n   *\n   * ```ts\n   * // named substitution so no need to escape colon\n   * $localize `${label}:label:: ${}`\n   * // anonymous substitution so colon must be escaped\n   * $localize `${label}\\: ${}`\n   * ```\n   *\n   * **Processing localized strings:**\n   *\n   * There are three scenarios:\n   *\n   * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a\n   * transpiler, removing the tag and replacing the template literal string with a translated\n   * literal string from a collection of translations provided to the transpilation tool.\n   *\n   * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and\n   * reorders the parts (static strings and expressions) of the template literal string with strings\n   * from a collection of translations loaded at run-time.\n   *\n   * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\n   * the original template literal string without applying any translations to the parts. This\n   * version is used during development or where there is no need to translate the localized\n   * template literals.\n   *\n   * @param messageParts a collection of the static parts of the template string.\n   * @param expressions a collection of the values of each placeholder in the template string.\n   * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\n   */\n  const $localize: LocalizeFn;\n}\n"],"names":[],"mappings":";;;;;;;;;;;IAAA;;;;;;;IAeA,IAAM,YAAY,GAAG,OAAO,UAAU,KAAK,WAAW,IAAI,UAAU,CAAC;IACrE,IAAM,QAAQ,GAAG,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC;IACzD,IAAM,MAAM,GAAG,OAAO,IAAI,KAAK,WAAW,IAAI,OAAO,iBAAiB,KAAK,WAAW;QAClF,IAAI,YAAY,iBAAiB,IAAI,IAAI,CAAC;IAC9C,IAAM,QAAQ,GAAG,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC;IACzD;IACA;IACA;AACA,IAAO,IAAM,OAAO,GAAQ,YAAY,IAAI,QAAQ,IAAI,QAAQ,IAAI,MAAM,CAAC;;ICvB3E;;;;;;;IA6CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2FA,IAAO,IAAM,SAAS,GAAe,UACjC,YAAkC;QAAE,qBAA8B;aAA9B,UAA8B,EAA9B,qBAA8B,EAA9B,IAA8B;YAA9B,oCAA8B;;QACpE,IAAI,SAAS,CAAC,SAAS,EAAE;;YAEvB,IAAM,WAAW,GAAG,SAAS,CAAC,SAAS,CAAC,YAAY,EAAE,WAAW,CAAC,CAAC;YACnE,YAAY,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;YAC9B,WAAW,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;SAC9B;QACD,IAAI,OAAO,GAAG,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAC/D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC5C,OAAO,IAAI,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;SAClF;QACD,OAAO,OAAO,CAAC;IACjB,CAAC,CAAC;IAEF,IAAM,YAAY,GAAG,GAAG,CAAC;IAEzB;;;;;;;;;;;;;IAaA,SAAS,UAAU,CAAC,WAAmB,EAAE,cAAsB;QAC7D,OAAO,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,YAAY;YAC5C,WAAW,CAAC,SAAS,CAAC,cAAc,CAAC,WAAW,EAAE,cAAc,CAAC,GAAG,CAAC,CAAC;YACtE,WAAW,CAAC;IAClB,CAAC;IAED;;;;;;;;;IASA,SAAS,cAAc,CAAC,MAAc,EAAE,GAAW;;;;;;;QAOjD,KAAK,IAAI,WAAW,GAAG,CAAC,EAAE,QAAQ,GAAG,CAAC,EAAE,WAAW,GAAG,MAAM,CAAC,MAAM,EAAE,WAAW,EAAE,EAAE,QAAQ,EAAE,EAAE;YAC9F,IAAI,GAAG,CAAC,QAAQ,CAAC,KAAK,IAAI,EAAE;gBAC1B,QAAQ,EAAE,CAAC;aACZ;iBAAM,IAAI,MAAM,CAAC,WAAW,CAAC,KAAK,YAAY,EAAE;gBAC/C,OAAO,WAAW,CAAC;aACpB;SACF;QACD,MAAM,IAAI,KAAK,CAAC,gDAA6C,GAAG,QAAI,CAAC,CAAC;IACxE,CAAC;;ICpMD;;;;;;OAMG;;ICNH;;;;;;;AAOA,IAIA;IACA,OAAO,CAAC,SAAS,GAAG,SAAS,CAAC;;;;"}