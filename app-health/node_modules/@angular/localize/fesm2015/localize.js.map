{"version":3,"file":"localize.js","sources":["../../../../../../packages/localize/src/utils/src/constants.ts","../../../../../../packages/localize/src/utils/src/messages.ts","../../../../../../packages/localize/src/utils/src/translations.ts","../../../../../../packages/localize/src/utils/index.ts","../../../../../../packages/localize/src/translate.ts","../../../../../../packages/localize/private.ts","../../../../../../packages/localize/localize.ts","../../../../../../packages/localize/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The character used to mark the start and end of a \"block\" in a `$localize` tagged string.\n * A block can indicate metadata about the message or specify a name of a placeholder for a\n * substitution expressions.\n *\n * For example:\n *\n * ```ts\n * $localize`Hello, ${title}:title:!`;\n * $localize`:meaning|description@@id:source message text`;\n * ```\n */\nexport const BLOCK_MARKER = ':';\n\n/**\n * The marker used to separate a message's \"meaning\" from its \"description\" in a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:correct|Indicates that the user got the answer correct: Right!`;\n * $localize `:movement|Button label for moving to the right: Right!`;\n * ```\n */\nexport const MEANING_SEPARATOR = '|';\n\n/**\n * The marker used to separate a message's custom \"id\" from its \"description\" in a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:A welcome message on the home page@@myApp-homepage-welcome: Welcome!`;\n * ```\n */\nexport const ID_SEPARATOR = '@@';\n\n/**\n * The marker used to separate legacy message ids from the rest of a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:@@custom-idâ2df64767cd895a8fabe3e18b94b5b6b6f9e2e3f0: Welcome!`;\n * ```\n *\n * Note that this character is the \"symbol for the unit separator\" (â) not the \"unit separator\n * character\" itself, since that has no visual representation. See https://graphemica.com/%E2%90%9F.\n *\n * Here is some background for the original \"unit separator character\":\n * https://stackoverflow.com/questions/8695118/whats-the-file-group-record-unit-separator-control-characters-and-its-usage\n */\nexport const LEGACY_ID_INDICATOR = '\\u241F';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {computeMsgId} from '@angular/compiler';\n\nimport {BLOCK_MARKER, ID_SEPARATOR, LEGACY_ID_INDICATOR, MEANING_SEPARATOR} from './constants';\n\n/**\n * Re-export this helper function so that users of `@angular/localize` don't need to actively import\n * from `@angular/compiler`.\n */\nexport {computeMsgId} from '@angular/compiler';\n\n/**\n * A string containing a translation source message.\n *\n * I.E. the message that indicates what will be translated from.\n *\n * Uses `{$placeholder-name}` to indicate a placeholder.\n */\nexport type SourceMessage = string;\n\n/**\n * A string containing a translation target message.\n *\n * I.E. the message that indicates what will be translated to.\n *\n * Uses `{$placeholder-name}` to indicate a placeholder.\n */\nexport type TargetMessage = string;\n\n/**\n * A string that uniquely identifies a message, to be used for matching translations.\n */\nexport type MessageId = string;\n\n/**\n * Information parsed from a `$localize` tagged string that is used to translate it.\n *\n * For example:\n *\n * ```\n * const name = 'Jo Bloggs';\n * $localize`Hello ${name}:title!`;\n * ```\n *\n * May be parsed into:\n *\n * ```\n * {\n *   messageId: '6998194507597730591',\n *   substitutions: { title: 'Jo Bloggs' },\n *   messageString: 'Hello {$title}!',\n * }\n * ```\n */\nexport interface ParsedMessage {\n  /**\n   * The key used to look up the appropriate translation target.\n   */\n  messageId: MessageId;\n  /**\n   * Legacy message ids, if provided.\n   *\n   * In legacy message formats the message id can only be computed directly from the original\n   * template source.\n   *\n   * Since this information is not available in `$localize` calls, the legacy message ids may be\n   * attached by the compiler to the `$localize` metablock so it can be used if needed at the point\n   * of translation if the translations are encoded using the legacy message id.\n   */\n  legacyIds: MessageId[];\n  /**\n   * A mapping of placeholder names to substitution values.\n   */\n  substitutions: Record<string, any>;\n  /**\n   * A human readable rendering of the message\n   */\n  messageString: string;\n  /**\n   * The meaning of the `message`, used to distinguish identical `messageString`s.\n   */\n  meaning: string;\n  /**\n   * The description of the `message`, used to aid translation.\n   */\n  description: string;\n  /**\n   * The static parts of the message.\n   */\n  messageParts: string[];\n  /**\n   * The names of the placeholders that will be replaced with substitutions.\n   */\n  placeholderNames: string[];\n}\n\n/**\n * Parse a `$localize` tagged string into a structure that can be used for translation.\n *\n * See `ParsedMessage` for an example.\n */\nexport function parseMessage(\n    messageParts: TemplateStringsArray, expressions?: readonly any[]): ParsedMessage {\n  const substitutions: {[placeholderName: string]: any} = {};\n  const metadata = parseMetadata(messageParts[0], messageParts.raw[0]);\n  const cleanedMessageParts: string[] = [metadata.text];\n  const placeholderNames: string[] = [];\n  let messageString = metadata.text;\n  for (let i = 1; i < messageParts.length; i++) {\n    const {text: messagePart, block: placeholderName = computePlaceholderName(i)} =\n        splitBlock(messageParts[i], messageParts.raw[i]);\n    messageString += `{$${placeholderName}}${messagePart}`;\n    if (expressions !== undefined) {\n      substitutions[placeholderName] = expressions[i - 1];\n    }\n    placeholderNames.push(placeholderName);\n    cleanedMessageParts.push(messagePart);\n  }\n  const messageId = metadata.id || computeMsgId(messageString, metadata.meaning || '');\n  const legacyIds = metadata.legacyIds.filter(id => id !== messageId);\n  return {\n    messageId,\n    legacyIds,\n    substitutions,\n    messageString,\n    meaning: metadata.meaning || '',\n    description: metadata.description || '',\n    messageParts: cleanedMessageParts, placeholderNames,\n  };\n}\n\nexport interface MessageMetadata {\n  text: string;\n  meaning: string|undefined;\n  description: string|undefined;\n  id: string|undefined;\n  legacyIds: string[];\n}\n\n/**\n * Parse the given message part (`cooked` + `raw`) to extract the message metadata from the text.\n *\n * If the message part has a metadata block this function will extract the `meaning`,\n * `description`, `customId` and `legacyId` (if provided) from the block. These metadata properties\n * are serialized in the string delimited by `|`, `@@` and `â` respectively.\n *\n * (Note that `â` is the `LEGACY_ID_INDICATOR` - see `constants.ts`.)\n *\n * For example:\n *\n * ```ts\n * `:meaning|description@@custom-id`\n * `:meaning|@@custom-id`\n * `:meaning|description`\n * `description@@custom-id`\n * `meaning|`\n * `description`\n * `@@custom-id`\n * `:meaning|description@@custom-idâlegacy-id-1âlegacy-id-2`\n * ```\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns A object containing any metadata that was parsed from the message part.\n */\nexport function parseMetadata(cooked: string, raw: string): MessageMetadata {\n  const {text, block} = splitBlock(cooked, raw);\n  if (block === undefined) {\n    return {text, meaning: undefined, description: undefined, id: undefined, legacyIds: []};\n  } else {\n    const [meaningDescAndId, ...legacyIds] = block.split(LEGACY_ID_INDICATOR);\n    const [meaningAndDesc, id] = meaningDescAndId.split(ID_SEPARATOR, 2);\n    let [meaning, description]: (string | undefined)[] = meaningAndDesc.split(MEANING_SEPARATOR, 2);\n    if (description === undefined) {\n      description = meaning;\n      meaning = undefined;\n    }\n    if (description === '') {\n      description = undefined;\n    }\n    return {text, meaning, description, id, legacyIds};\n  }\n}\n\n/**\n * Split a message part (`cooked` + `raw`) into an optional delimited \"block\" off the front and the\n * rest of the text of the message part.\n *\n * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the\n * start and end of the block.\n *\n * If the block is in the first message part then it will be metadata about the whole message:\n * meaning, description, id.  Otherwise it will be metadata about the immediately preceding\n * substitution: placeholder name.\n *\n * Since blocks are optional, it is possible that the content of a message block actually starts\n * with a block marker. In this case the marker must be escaped `\\:`.\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns An object containing the `text` of the message part and the text of the `block`, if it\n * exists.\n * @throws an error if the `block` is unterminated\n */\nexport function splitBlock(cooked: string, raw: string): {text: string, block?: string} {\n  if (raw.charAt(0) !== BLOCK_MARKER) {\n    return {text: cooked};\n  } else {\n    const endOfBlock = findEndOfBlock(cooked, raw);\n    return {\n      block: cooked.substring(1, endOfBlock),\n      text: cooked.substring(endOfBlock + 1),\n    };\n  }\n}\n\n\nfunction computePlaceholderName(index: number) {\n  return index === 1 ? 'PH' : `PH_${index - 1}`;\n}\n\n/**\n * Find the end of a \"marked block\" indicated by the first non-escaped colon.\n *\n * @param cooked The cooked string (where escaped chars have been processed)\n * @param raw The raw string (where escape sequences are still in place)\n *\n * @returns the index of the end of block marker\n * @throws an error if the block is unterminated\n */\nexport function findEndOfBlock(cooked: string, raw: string): number {\n  /************************************************************************************************\n  * This function is repeated in `src/localize/src/localize.ts` and the two should be kept in sync.\n  * (See that file for more explanation of why.)\n  ************************************************************************************************/\n  for (let cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {\n    if (raw[rawIndex] === '\\\\') {\n      rawIndex++;\n    } else if (cooked[cookedIndex] === BLOCK_MARKER) {\n      return cookedIndex;\n    }\n  }\n  throw new Error(`Unterminated $localize metadata block in \"${raw}\".`);\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {BLOCK_MARKER} from './constants';\nimport {MessageId, ParsedMessage, TargetMessage, parseMessage} from './messages';\n\n\n/**\n * A translation message that has been processed to extract the message parts and placeholders.\n */\nexport interface ParsedTranslation {\n  messageParts: TemplateStringsArray;\n  placeholderNames: string[];\n}\n\n/**\n * The internal structure used by the runtime localization to translate messages.\n */\nexport type ParsedTranslations = Record<MessageId, ParsedTranslation>;\n\nexport class MissingTranslationError extends Error {\n  private readonly type = 'MissingTranslationError';\n  constructor(readonly parsedMessage: ParsedMessage) {\n    super(`No translation found for ${describeMessage(parsedMessage)}.`);\n  }\n}\n\nexport function isMissingTranslationError(e: any): e is MissingTranslationError {\n  return e.type === 'MissingTranslationError';\n}\n\n/**\n * Translate the text of the `$localize` tagged-string (i.e. `messageParts` and\n * `substitutions`) using the given `translations`.\n *\n * The tagged-string is parsed to extract its `messageId` which is used to find an appropriate\n * `ParsedTranslation`. If this doesn't match and there are legacy ids then try matching a\n * translation using those.\n *\n * If one is found then it is used to translate the message into a new set of `messageParts` and\n * `substitutions`.\n * The translation may reorder (or remove) substitutions as appropriate.\n *\n * If there is no translation with a matching message id then an error is thrown.\n * If a translation contains a placeholder that is not found in the message being translated then an\n * error is thrown.\n */\nexport function translate(\n    translations: Record<string, ParsedTranslation>, messageParts: TemplateStringsArray,\n    substitutions: readonly any[]): [TemplateStringsArray, readonly any[]] {\n  const message = parseMessage(messageParts, substitutions);\n  // Look up the translation using the messageId, and then the legacyId if available.\n  let translation = translations[message.messageId];\n  // If the messageId did not match a translation, try matching the legacy ids instead\n  for (let i = 0; i < message.legacyIds.length && translation === undefined; i++) {\n    translation = translations[message.legacyIds[i]];\n  }\n  if (translation === undefined) {\n    throw new MissingTranslationError(message);\n  }\n  return [\n    translation.messageParts, translation.placeholderNames.map(placeholder => {\n      if (message.substitutions.hasOwnProperty(placeholder)) {\n        return message.substitutions[placeholder];\n      } else {\n        throw new Error(\n            `There is a placeholder name mismatch with the translation provided for the message ${describeMessage(message)}.\\n` +\n            `The translation contains a placeholder with name ${placeholder}, which does not exist in the message.`);\n      }\n    })\n  ];\n}\n\n/**\n * Parse the `messageParts` and `placeholderNames` out of a target `message`.\n *\n * Used by `loadTranslations()` to convert target message strings into a structure that is more\n * appropriate for doing translation.\n *\n * @param message the message to be parsed.\n */\nexport function parseTranslation(message: TargetMessage): ParsedTranslation {\n  const parts = message.split(/{\\$([^}]*)}/);\n  const messageParts = [parts[0]];\n  const placeholderNames: string[] = [];\n  for (let i = 1; i < parts.length - 1; i += 2) {\n    placeholderNames.push(parts[i]);\n    messageParts.push(`${parts[i + 1]}`);\n  }\n  const rawMessageParts =\n      messageParts.map(part => part.charAt(0) === BLOCK_MARKER ? '\\\\' + part : part);\n  return {messageParts: makeTemplateObject(messageParts, rawMessageParts), placeholderNames};\n}\n\n/**\n * Create a `ParsedTranslation` from a set of `messageParts` and `placeholderNames`.\n *\n * @param messageParts The message parts to appear in the ParsedTranslation.\n * @param placeholderNames The names of the placeholders to intersperse between the `messageParts`.\n */\nexport function makeParsedTranslation(\n    messageParts: string[], placeholderNames: string[] = []): ParsedTranslation {\n  return {messageParts: makeTemplateObject(messageParts, messageParts), placeholderNames};\n}\n\n/**\n * Create the specialized array that is passed to tagged-string tag functions.\n *\n * @param cooked The message parts with their escape codes processed.\n * @param raw The message parts with their escaped codes as-is.\n */\nexport function makeTemplateObject(cooked: string[], raw: string[]): TemplateStringsArray {\n  Object.defineProperty(cooked, 'raw', {value: raw});\n  return cooked as any;\n}\n\n\nfunction describeMessage(message: ParsedMessage): string {\n  const meaningString = message.meaning && ` - \"${message.meaning}\"`;\n  return `\"${message.messageId}\" (\"${message.messageString}\"${meaningString})`;\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport * from './src/constants';\nexport * from './src/messages';\nexport * from './src/translations';","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {LocalizeFn} from './localize';\nimport {MessageId, ParsedTranslation, TargetMessage, parseTranslation, translate as _translate} from './utils';\n\n/**\n * We augment the `$localize` object to also store the translations.\n *\n * Note that because the TRANSLATIONS are attached to a global object, they will be shared between\n * all applications that are running in a single page of the browser.\n */\ndeclare const $localize: LocalizeFn&{TRANSLATIONS: Record<MessageId, ParsedTranslation>};\n\n/**\n * Load translations for `$localize`.\n *\n * The given `translations` are processed and added to a lookup based on their `MessageId`.\n * A new translation will overwrite a previous translation if it has the same `MessageId`.\n *\n * * If a message is generated by the Angular compiler from an `i18n` marker in a template, the\n *   `MessageId` is passed through to the `$localize` call as a custom `MessageId`. The `MessageId`\n *   will match what is extracted into translation files.\n *\n * * If the translation is from a call to `$localize` in application code, and no custom `MessageId`\n *   is provided, then the `MessageId` can be generated by passing the tagged string message-parts\n *   to the `parseMessage()` function (not currently public API).\n *\n * @publicApi\n *\n */\nexport function loadTranslations(translations: Record<MessageId, TargetMessage>) {\n  // Ensure the translate function exists\n  if (!$localize.translate) {\n    $localize.translate = translate;\n  }\n  if (!$localize.TRANSLATIONS) {\n    $localize.TRANSLATIONS = {};\n  }\n  Object.keys(translations).forEach(key => {\n    $localize.TRANSLATIONS[key] = parseTranslation(translations[key]);\n  });\n}\n\n/**\n * Remove all translations for `$localize`.\n *\n * @publicApi\n */\nexport function clearTranslations() {\n  $localize.translate = undefined;\n  $localize.TRANSLATIONS = {};\n}\n\n/**\n * Translate the text of the given message, using the loaded translations.\n *\n * This function may reorder (or remove) substitutions as indicated in the matching translation.\n */\nexport function translate(messageParts: TemplateStringsArray, substitutions: readonly any[]):\n    [TemplateStringsArray, readonly any[]] {\n  try {\n    return _translate($localize.TRANSLATIONS, messageParts, substitutions);\n  } catch (e) {\n    console.warn(e.message);\n    return [messageParts, substitutions];\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// This file exports all the `utils` as private exports so that other parts of `@angular/localize`\n// can make use of them.\nexport {MessageId as ÉµMessageId, MissingTranslationError as ÉµMissingTranslationError, ParsedMessage as ÉµParsedMessage, ParsedTranslation as ÉµParsedTranslation, ParsedTranslations as ÉµParsedTranslations, SourceMessage as ÉµSourceMessage, TargetMessage as ÉµTargetMessage, computeMsgId as ÉµcomputeMsgId, findEndOfBlock as ÉµfindEndOfBlock, isMissingTranslationError as ÉµisMissingTranslationError, makeParsedTranslation as ÉµmakeParsedTranslation, makeTemplateObject as ÉµmakeTemplateObject, parseMessage as ÉµparseMessage, parseMetadata as ÉµparseMetadata, parseTranslation as ÉµparseTranslation, splitBlock as ÉµsplitBlock, translate as Éµtranslate} from './src/utils';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// This file contains the public API of the `@angular/localize` entry-point\n\nexport {clearTranslations, loadTranslations} from './src/translate';\n\n// Exports that are not part of the public API\nexport * from './private';","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// DO NOT ADD public exports to this file.\n// The public API exports are specified in the `./localize` module, which is checked by the\n// public_api_guard rules\n\nexport * from './localize';"],"names":["translate","_translate"],"mappings":"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"}