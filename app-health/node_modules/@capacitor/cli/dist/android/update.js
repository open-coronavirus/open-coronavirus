"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../common");
const common_2 = require("./common");
const cordova_1 = require("../cordova");
const fs_1 = require("../util/fs");
const path_1 = require("path");
const plugin_1 = require("../plugin");
const platform = 'android';
async function updateAndroid(config) {
    let plugins = await getPluginsTask(config);
    const capacitorPlugins = plugins.filter(p => plugin_1.getPluginType(p, platform) === 0 /* Core */);
    let needsPluginUpdate = true;
    while (needsPluginUpdate) {
        needsPluginUpdate = await cordova_1.checkAndInstallDependencies(config, plugins, platform);
        if (needsPluginUpdate) {
            plugins = await getPluginsTask(config);
        }
    }
    plugin_1.printPlugins(capacitorPlugins, 'android');
    removePluginsNativeFiles(config);
    const cordovaPlugins = plugins
        .filter(p => plugin_1.getPluginType(p, platform) === 1 /* Cordova */);
    if (cordovaPlugins.length > 0) {
        copyPluginsNativeFiles(config, cordovaPlugins);
    }
    await cordova_1.handleCordovaPluginsJS(cordovaPlugins, config, platform);
    await installGradlePlugins(config, capacitorPlugins, cordovaPlugins);
    await handleCordovaPluginsGradle(config, cordovaPlugins);
    await cordova_1.writeCordovaAndroidManifest(cordovaPlugins, config, platform);
    const incompatibleCordovaPlugins = plugins
        .filter(p => plugin_1.getPluginType(p, platform) === 2 /* Incompatible */);
    plugin_1.printPlugins(incompatibleCordovaPlugins, platform, 'incompatible');
    await common_1.checkPlatformVersions(config, platform);
}
exports.updateAndroid = updateAndroid;
function getGradlePackageName(id) {
    return id.replace('@', '').replace('/', '-');
}
async function installGradlePlugins(config, capacitorPlugins, cordovaPlugins) {
    const capacitorAndroidPath = common_1.resolveNode(config, '@capacitor/android', 'capacitor');
    if (!capacitorAndroidPath) {
        common_1.logFatal(`Unable to find node_modules/@capacitor/android/capacitor. Are you sure`, `@capacitor/android is installed? This file is currently required for Capacitor to function.`);
        return;
    }
    const settingsPath = path_1.join(config.app.rootDir, 'android');
    const dependencyPath = path_1.join(config.app.rootDir, 'android', 'app');
    const relativeCapcitorAndroidPath = fs_1.convertToUnixPath(path_1.relative(settingsPath, capacitorAndroidPath));
    const settingsLines = `// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN
include ':capacitor-android'
project(':capacitor-android').projectDir = new File('${relativeCapcitorAndroidPath}')
${capacitorPlugins.map(p => {
        const relativePluginPath = fs_1.convertToUnixPath(path_1.relative(settingsPath, p.rootPath));
        return `
include ':${getGradlePackageName(p.id)}'
project(':${getGradlePackageName(p.id)}').projectDir = new File('${relativePluginPath}/${p.android.path}')
`;
    }).join('')}`;
    let applyArray = [];
    let frameworksArray = [];
    let prefsArray = [];
    cordovaPlugins.map(p => {
        const relativePluginPath = fs_1.convertToUnixPath(path_1.relative(dependencyPath, p.rootPath));
        const frameworks = plugin_1.getPlatformElement(p, platform, 'framework');
        frameworks.map((framework) => {
            if (framework.$.custom && framework.$.custom === 'true' && framework.$.type && framework.$.type === 'gradleReference') {
                applyArray.push(`apply from: "${relativePluginPath}/${framework.$.src}"`);
            }
            else if (!framework.$.type && !framework.$.custom) {
                frameworksArray.push(`    implementation "${framework.$.src}"`);
            }
        });
        prefsArray = prefsArray.concat(plugin_1.getAllElements(p, platform, 'preference'));
    });
    let frameworkString = frameworksArray.join('\n');
    prefsArray.map((preference) => {
        frameworkString = frameworkString.replace(new RegExp(('$' + preference.$.name).replace('$', '\\$&'), 'g'), preference.$.default);
    });
    const dependencyLines = `// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN

android {
  compileOptions {
      sourceCompatibility JavaVersion.VERSION_1_8
      targetCompatibility JavaVersion.VERSION_1_8
  }
}

apply from: "../capacitor-cordova-android-plugins/cordova.variables.gradle"
dependencies {
${capacitorPlugins.map(p => {
        return `    implementation project(':${getGradlePackageName(p.id)}')`;
    }).join('\n')}
${frameworkString}
}
${applyArray.join('\n')}

if (hasProperty('postBuildExtras')) {
  postBuildExtras()
}
`;
    await fs_1.writeFileAsync(path_1.join(settingsPath, 'capacitor.settings.gradle'), settingsLines);
    await fs_1.writeFileAsync(path_1.join(dependencyPath, 'capacitor.build.gradle'), dependencyLines);
}
exports.installGradlePlugins = installGradlePlugins;
async function handleCordovaPluginsGradle(config, cordovaPlugins) {
    const pluginsFolder = path_1.resolve(config.app.rootDir, 'android', config.android.assets.pluginsFolderName);
    const pluginsGradlePath = path_1.join(pluginsFolder, 'build.gradle');
    let frameworksArray = [];
    let prefsArray = [];
    let applyArray = [];
    applyArray.push(`apply from: "cordova.variables.gradle"`);
    cordovaPlugins.map(p => {
        const relativePluginPath = fs_1.convertToUnixPath(path_1.relative(pluginsFolder, p.rootPath));
        const frameworks = plugin_1.getPlatformElement(p, platform, 'framework');
        frameworks.map((framework) => {
            if (!framework.$.type && !framework.$.custom) {
                frameworksArray.push(framework.$.src);
            }
            else if (framework.$.custom && framework.$.custom === 'true' && framework.$.type && framework.$.type === 'gradleReference') {
                applyArray.push(`apply from: "${relativePluginPath}/${framework.$.src}"`);
            }
        });
        prefsArray = prefsArray.concat(plugin_1.getAllElements(p, platform, 'preference'));
    });
    let frameworkString = frameworksArray.map(f => {
        return `    implementation "${f}"`;
    }).join('\n');
    prefsArray.map((preference) => {
        frameworkString = frameworkString.replace(new RegExp(('$' + preference.$.name).replace('$', '\\$&'), 'g'), preference.$.default);
    });
    let applyString = applyArray.join('\n');
    let buildGradle = await fs_1.readFileAsync(pluginsGradlePath, 'utf8');
    buildGradle = buildGradle.replace(/(SUB-PROJECT DEPENDENCIES START)[\s\S]*(\/\/ SUB-PROJECT DEPENDENCIES END)/, '$1\n' + frameworkString.concat('\n') + '    $2');
    buildGradle = buildGradle.replace(/(PLUGIN GRADLE EXTENSIONS START)[\s\S]*(\/\/ PLUGIN GRADLE EXTENSIONS END)/, '$1\n' + applyString.concat('\n') + '$2');
    await fs_1.writeFileAsync(pluginsGradlePath, buildGradle);
    const cordovaVariables = `// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN
ext {
  cdvMinSdkVersion = ${config.android.minVersion}
  // Plugin gradle extensions can append to this to have code run at the end.
  cdvPluginPostBuildExtras = []
}`;
    await fs_1.writeFileAsync(path_1.join(pluginsFolder, 'cordova.variables.gradle'), cordovaVariables);
}
exports.handleCordovaPluginsGradle = handleCordovaPluginsGradle;
function copyPluginsNativeFiles(config, cordovaPlugins) {
    const pluginsRoot = path_1.resolve(config.app.rootDir, 'android', config.android.assets.pluginsFolderName);
    const pluginsPath = path_1.join(pluginsRoot, 'src', 'main');
    cordovaPlugins.map(p => {
        const androidPlatform = plugin_1.getPluginPlatform(p, platform);
        if (androidPlatform) {
            const sourceFiles = androidPlatform['source-file'];
            if (sourceFiles) {
                sourceFiles.map((sourceFile) => {
                    const fileName = sourceFile.$.src.split('/').pop();
                    let baseFolder = 'java/';
                    if (fileName.split('.').pop() === 'aidl') {
                        baseFolder = 'aidl/';
                    }
                    const target = sourceFile.$['target-dir'].replace('app/src/main/', '').replace('src/', baseFolder);
                    fs_1.copySync(plugin_1.getFilePath(config, p, sourceFile.$.src), path_1.join(pluginsPath, target, fileName));
                });
            }
            const resourceFiles = androidPlatform['resource-file'];
            if (resourceFiles) {
                resourceFiles.map((resourceFile) => {
                    const target = resourceFile.$['target'];
                    if (resourceFile.$.src.split('.').pop() === 'aar') {
                        fs_1.copySync(plugin_1.getFilePath(config, p, resourceFile.$.src), path_1.join(pluginsPath, 'libs', target.split('/').pop()));
                    }
                    else if (target !== '.') {
                        fs_1.copySync(plugin_1.getFilePath(config, p, resourceFile.$.src), path_1.join(pluginsPath, target));
                    }
                });
            }
            const libFiles = plugin_1.getPlatformElement(p, platform, 'lib-file');
            libFiles.map((libFile) => {
                fs_1.copySync(plugin_1.getFilePath(config, p, libFile.$.src), path_1.join(pluginsPath, 'libs', libFile.$.src.split('/').pop()));
            });
        }
    });
}
function removePluginsNativeFiles(config) {
    const pluginsRoot = path_1.resolve(config.app.rootDir, 'android', config.android.assets.pluginsFolderName);
    fs_1.removeSync(pluginsRoot);
    fs_1.copySync(config.android.assets.pluginsDir, pluginsRoot);
}
async function getPluginsTask(config) {
    return await common_1.runTask('Updating Android plugins', async () => {
        const allPlugins = await plugin_1.getPlugins(config);
        const androidPlugins = common_2.getAndroidPlugins(allPlugins);
        return androidPlugins;
    });
}
